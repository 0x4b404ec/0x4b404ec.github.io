[{"content":"利用Hugo+Github Pages搭建个人博客 转载于：https://www.cnblogs.com/liumylay/articles/17936667.html\n转载于：https://www.cnblogs.com/liumylay/articles/17936667.html\n转载于：https://www.cnblogs.com/liumylay/articles/17936667.html\n前言 创建 GitHub 帐户\n安装git，下载对应系统版本 exe ，无脑点击下一步。\n安装hugo(extended edition, v0.112.0 or later)\n打开 Github 中的 Hugo 库，打开右边侧边栏About下面的 Realeases，下载最新的版本，本次下载为：hugo_extended_0.121.1_windows-amd64.zip\n解压后，将其中的 hugo.exe 放到指定的安装目录，比如 D:\\softwares\\Hugo\\bin，然后将该目录添加到系统环境变量（win+R → sysdm.cpl → 高级 → 环境变量 → 系统变量 Path）的 Path 下。\n打开命令行，输入 hugo version，显示版本号即为安装成功\n在几分钟内利用hugo快速发布自己的个人博客 快速开始 使用Git Bash依次输入以下命令，即可建立预览一个PaperMod主题的hugo网站：\n1 2 3 4 5 6 hugo new site myblog cd myblog git init git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod echo \u0026#34;theme = \u0026#39;PaperMod\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml hugo server 通过终端中显示的 URL 查看您的站点。按此按钮Ctrl + C可停止 Hugo 的开发服务器。\n命令解释 在目录中为您的博客创建一个以myblog命名的文件夹目录结构\n1 hugo new site myblog 将当前目录更改为博客的根目录。\n1 cd myblog 在当前目录中初始化一个空的 Git 存储库。\n1 git init 将PaperMod主题克隆到博客目录结构中，并将其作为Git 子模块themes添加到您的博客中。\n1 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 在博客配置文件hugo.toml(位于根目录)中添加一行，表明为PaperMod主题。\n1 echo \u0026#34;theme = \u0026#39;PaperMod\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 启动Hugo的开发服务器来预览博客。\n1 hugo server 按此按钮Ctrl + C可停止预览博客。\n添加内容 向您的网站添加新页面。\n1 2 3 hugo new posts/文章标题/index.md # posts为你文章存储的文件夹名，可任取 # 默认生成路径为content/posts/文章 为什么使用这个路径来存放文章，见这篇文章链接：https://www.cnblogs.com/liumylay/articles/17936688.html\n使用任意文本编辑器打开文件my-first-post.md，可以看到默认内容为：\n1 2 3 4 5 --- title: \u0026#34;My First Post\u0026#34; date: 2022-11-20T09:03:20-08:00 draft: true --- 请注意draft中的值为true，代表草稿状态。默认情况下，Hugo 在您构建网站时不会发布草稿内容。\n1 2 3 4 5 6 7 8 9 --- title: \u0026#34;My First Post\u0026#34; date: 2022-11-20T09:03:20-08:00 draft: true --- ## Introduction This is **bold** text, and this is *emphasized* text. Visit the [Hugo](https://gohugo.io) website! 保存文件，然后启动Hugo的开发服务器来预览博客。您可以运行以下任一命令来预览草稿内容。\n1 2 hugo server --buildDrafts hugo server -D 通过终端中显示的 URL 查看您的博客。当您继续添加和更改内容时，请保持开发服务器运行。\n由于 Hugo 默认开启了热加载功能，所以我们不需要中断已启动的 Hugo 服务，可以在另外一个终端窗口的当前目录下执行其他操作或者修改文章，这些修改后的文章会自动在网页上实时渲染，这样你就可以同步实时观察修改后的网页效果。\n配置网站 使用编辑器打开项目根目录中的博客配置文件 ( hugo.toml)。\n1 2 3 4 baseURL = \u0026#39;https://example.org/\u0026#39; languageCode = \u0026#39;en-us\u0026#39; title = \u0026#39;My New Hugo Site\u0026#39; theme = \u0026#39;PaperMod\u0026#39; 进行以下更改：\n为您的网站设置baseURL。该值必须以协议开头并以斜杠结尾，如上所示。 设置languageCode为您的语言和区域（中文简体为zh-CN）。 为您的网站设置标题title。 启动 Hugo 的开发服务器以查看您的更改，请记住包含草稿内容。\n1 hugo server -D 发布网站 在此步骤中，您将发布您的网站，但不会部署它。\n当您发布public站点时，Hugo 在项目根目录的目录中创建整个静态站点。这包括 HTML 文件以及图像、CSS 文件和 JavaScript 文件等资产。\n当您发布网站时，您通常不希望包含草稿、未来或过期的内容。命令很简单：\n1 hugo 在互联网上利用Github Pages部署个人博客 GitHub 通过 GitHub Pages 服务直接从 GitHub 存储库通过 SSL 为个人、组织或项目页面提供免费、快速的静态托管，并自动化开发工作流程并使用 GitHub Actions 进行构建。\nStep1.创建Github存储库。 注意库名必须以用户名开头，例如：我的用户名是liumy-lay，则库名为liumy-lay.github.io\nStep2.将本地存储库推送到 GitHub 报错：由于生成本地git库的分支默认是master，而github库默认分支为main，因此git push时会出现各种报错 解决：将本地分支改名为main，重新git push会报fatal，根据fatal提示内容强制推送即可解决。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ git remote add origin git@github.com:liumy-lay/liumy-lay.github.io.git # 将本地git库与远程Github库建立联系 $ git add . $ git commit -m \u0026#39;first commit\u0026#39; $ git push origin main error: src refspec main does not match any error: failed to push some refs to \u0026#39;github.com:liumy-lay/liumy-lay.github.io.git\u0026#39; $ git branch -M main # 将当前分支改名为main $ git branch -a # 可以查看当前所有分支，此命令非必要 $ git push origin fatal: The current branch main has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin main $ git push --set-upstream origin main --force #强制推送合并分支 Enumerating objects: 32, done. Counting objects: 100% (32/32), done. Delta compression using up to 16 threads Compressing objects: 100% (24/24), done. Writing objects: 100% (32/32), 49.14 KiB | 137.00 KiB/s, done. Total 32 (delta 5), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (5/5), done. To github.com:liumy-lay/liumy-lay.github.io.git + b899144...23b296b main -\u0026gt; main (forced update) branch \u0026#39;main\u0026#39; set up to track \u0026#39;origin/main\u0026#39;. Step3.访问您的 GitHub 存储库，从主菜单中选择设置 \u0026gt; 页面。 在屏幕中央，将源更改为GitHub Actions。改变是立竿见影的；您不必按“保存”按钮。 Step4.在本地存储库中根目录下创建一个空文件 .github/workflows/hugo.yaml Step5.将下面的 YAML 复制并粘贴到您创建的文件中。根据需要更改分支名称和 Hugo 版本。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # 分支名称默认为main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.121.0 # Hugo版本号 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v4 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: # For maximum backward compatibility with Hugo modules HUGO_ENVIRONMENT: production HUGO_ENV: production run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v2 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v3 Step6.使用“Add workflows”之类的提交消息将更改提交到本地存储库，然后推送到 GitHub。 1 2 3 4 5 6 7 8 9 10 11 12 $ git add . $ git commit -m \u0026#39;Add workflows\u0026#39; $ git push origin Enumerating objects: 6, done. Counting objects: 100% (6/6), done. Delta compression using up to 16 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (5/5), 1.32 KiB | 1.32 MiB/s, done. Total 5 (delta 1), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (1/1), completed with 1 local object. To github.com:liumy-lay/liumy-lay.github.io.git 23b296b..aec5cc1 main -\u0026gt; main Step7.从 GitHub 的主菜单中，选择Actions。 当 GitHub 完成站点的构建和部署后，状态指示器的颜色将变为绿色。在部署步骤下，您将看到指向您的实时站点的链接。\n将来，每当您从本地存储库推送更改时，GitHub 都会重建您的站点并部署更改。\n总结 日常发布文章命令\n1 2 3 4 5 6 7 $ hugo new [posts]/[name]/index.md $ hugo server -D $ hugo $ git status $ git add . $ git commit -m \u0026#39;[描述信息]\u0026#39; $ git push origin 参考资料：\nhttps://gohugo.io/getting-started/quick-start/\nhttps://gohugo.io/hosting-and-deployment/hosting-on-github/\n","permalink":"https://0x4b404ec.github.io/posts/hugo+githubaction%E6%90%AD%E5%BB%BApages-%E8%BD%AC/","summary":"利用Hugo+Github Pages搭建个人博客 转载于：https://www.cnblogs.com/liumylay/articles/17936667.html\n转载于：https://www.cnblogs.com/liumylay/articles/17936667.html\n转载于：https://www.cnblogs.com/liumylay/articles/17936667.html\n前言 创建 GitHub 帐户\n安装git，下载对应系统版本 exe ，无脑点击下一步。\n安装hugo(extended edition, v0.112.0 or later)\n打开 Github 中的 Hugo 库，打开右边侧边栏About下面的 Realeases，下载最新的版本，本次下载为：hugo_extended_0.121.1_windows-amd64.zip\n解压后，将其中的 hugo.exe 放到指定的安装目录，比如 D:\\softwares\\Hugo\\bin，然后将该目录添加到系统环境变量（win+R → sysdm.cpl → 高级 → 环境变量 → 系统变量 Path）的 Path 下。\n打开命令行，输入 hugo version，显示版本号即为安装成功\n在几分钟内利用hugo快速发布自己的个人博客 快速开始 使用Git Bash依次输入以下命令，即可建立预览一个PaperMod主题的hugo网站：\n1 2 3 4 5 6 hugo new site myblog cd myblog git init git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod echo \u0026#34;theme = \u0026#39;PaperMod\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.","title":"[转] Hugo+GithubAction搭建Pages"},{"content":"Unity PlayableDirector(Timeline) 正播倒播处理 项目要求控制Timeline的播放状态，官方给出的方案只有正播的处理，并没有倒播的接口。\n而且网上搜索的一些方案都是使用协程，但是协程在处理中途暂停继续播放上比较难处理。\n所以自己随便写了一个。处理上比较傻瓜。\n下载DoTween插件 略\u0026hellip;\nTimelineHelper.cs 主要是提供了两个静态接口，用来实现挂TimelineDirector组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using UnityEngine; using UnityEngine.Playables; public static class PlayableExpansion { /// \u0026lt;summary\u0026gt; /// 为director添加自定义控制器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;director\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static PlayableController AddPlayableController(this PlayableDirector director) { return director.gameObject.AddComponent\u0026lt;PlayableController\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 为obj添加自定义控制器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static PlayableController AddPlayableController(this GameObject obj) { return obj.AddComponent\u0026lt;PlayableController\u0026gt;(); } } TimelineDirector.cs Timeline的相关控制封装，没有用官方播放的API，只用到了PlayableDirector时间和采样(PlayableDirector.time和PlayableDirector.Evaluate())\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 using DG.Tweening; using Sirenix.OdinInspector; using System; using UnityEngine; using UnityEngine.Playables; [RequireComponent(typeof(PlayableDirector))] public class PlayableController : MonoBehaviour { #region ENUM public enum Status { NULL, PLAYING, PAUSED, STOPPED, } public enum Direction { NULL, FORWARD, BACKWARD } #endregion [SerializeField] private PlayableDirector m_playableDirector; /// \u0026lt;summary\u0026gt; /// 当前播放状态(如果用不到可是删除，现在这个字段只是一个状态的记录) /// \u0026lt;/summary\u0026gt; public Status CurrentPlayStatus { get; private set; } = Status.NULL; /// \u0026lt;summary\u0026gt; /// 当前播放方向(如果用不到可是删除，现在这个字段只是一个状态的记录) /// \u0026lt;/summary\u0026gt; public Direction CurrentPlayDirection { get; private set; } = Direction.NULL; /// \u0026lt;summary\u0026gt; /// 当前播放进度 /// \u0026lt;/summary\u0026gt; public double FullProgress { get; private set; } = 0d; /// \u0026lt;summary\u0026gt; /// 片段进度 /// \u0026lt;/summary\u0026gt; //public double ClipProgress { get; private set; } = 0d; /// \u0026lt;summary\u0026gt; /// 当前播放进度归一化 /// \u0026lt;/summary\u0026gt; public double CurrentNormalizedProgress =\u0026gt; FullProgress / Duration; [Range(0f, 5f)] public float PlaySpeed = 1f; /// \u0026lt;summary\u0026gt; /// 播放模式 /// \u0026lt;/summary\u0026gt; public WrapMode WrapMode = WrapMode.Once; /// \u0026lt;summary\u0026gt; /// 开始播放事件, 返回时 时间点，和触发时方向 /// \u0026lt;/summary\u0026gt; public Action\u0026lt;double, Direction\u0026gt; OnPlay; /// \u0026lt;summary\u0026gt; /// 暂停播放事件, 返回时 时间点，和触发时方向 /// \u0026lt;/summary\u0026gt; public Action\u0026lt;double, Direction\u0026gt; OnPause; /// \u0026lt;summary\u0026gt; /// 停止播放事件, 返回时 时间点，和触发时方向 /// \u0026lt;/summary\u0026gt; public Action\u0026lt;double, Direction\u0026gt; OnStop; /// \u0026lt;summary\u0026gt; /// 继续播放事件, 返回时 时间点，和触发时方向 /// \u0026lt;/summary\u0026gt; public Action\u0026lt;double, Direction\u0026gt; OnContinue; /// \u0026lt;summary\u0026gt; /// 当播放自动停止，既本次的ProgressExecute播放到指定事件点时触发； /// \u0026lt;/summary\u0026gt; public Action\u0026lt;double\u0026gt; OnAutoStop; public Action\u0026lt;double\u0026gt; OnUpdate; /// \u0026lt;summary\u0026gt; /// Timeline长度 /// \u0026lt;/summary\u0026gt; public double Duration { get; private set; } = -1f; private Tweener m_timeTween; public bool TweenActive =\u0026gt; m_timeTween.IsActive(); private void Awake() { m_playableDirector = GetComponent\u0026lt;PlayableDirector\u0026gt;(); m_playableDirector.playOnAwake = false; Duration = m_playableDirector.duration; CurrentPlayStatus = Status.STOPPED; } /// \u0026lt;summary\u0026gt; /// 继续播放 /// \u0026lt;/summary\u0026gt; [Button] public void Continue() { if (m_timeTween.IsActive()) { CurrentPlayStatus = Status.PLAYING; m_timeTween.Play(); } OnContinue?.Invoke(FullProgress, CurrentPlayDirection); } /// \u0026lt;summary\u0026gt; /// 从暂停时间点正向播放, 应用在倒播中途暂停后切换为正播 /// \u0026lt;/summary\u0026gt; [Button] public void ContinuePlayForwardByPausePoint() { CurrentPlayStatus = Status.PLAYING; CurrentPlayDirection = Direction.FORWARD; m_timeTween.Kill(); ProgressExecute(Duration); OnContinue?.Invoke(FullProgress, CurrentPlayDirection); } /// \u0026lt;summary\u0026gt; /// 从暂停时间点反向播放, 应用在正播中途暂停后切换为倒播 /// \u0026lt;/summary\u0026gt; [Button] public void ContinuePlayBackwardByPausePoint() { CurrentPlayStatus = Status.PLAYING; CurrentPlayDirection = Direction.BACKWARD; m_timeTween.Kill(); ProgressExecute(0); OnContinue?.Invoke(FullProgress, CurrentPlayDirection); } public void PlayClip(double start, double stop) { if (start == stop) return; CurrentPlayStatus = Status.PLAYING; CurrentPlayDirection = start \u0026lt; stop ? Direction.FORWARD : Direction.BACKWARD; m_timeTween.Kill(); FullProgress = start; ProgressExecute(stop); OnPlay?.Invoke(start, CurrentPlayDirection); } /// \u0026lt;summary\u0026gt; /// 从开始播放 /// \u0026lt;/summary\u0026gt; [Button] public void PlayForward() { CurrentPlayStatus = Status.PLAYING; CurrentPlayDirection = Direction.FORWARD; m_timeTween.Kill(); FullProgress = 0d; ProgressExecute(Duration); OnPlay?.Invoke(FullProgress, CurrentPlayDirection); } /// \u0026lt;summary\u0026gt; /// 从结尾倒放 /// \u0026lt;/summary\u0026gt; [Button] public void PlayBackward() { CurrentPlayStatus = Status.PLAYING; CurrentPlayDirection = Direction.BACKWARD; m_timeTween.Kill(); FullProgress = Duration; ProgressExecute(0); OnPlay?.Invoke(FullProgress, CurrentPlayDirection); } /// \u0026lt;summary\u0026gt; /// 暂停播放 /// \u0026lt;/summary\u0026gt; [Button] public void Pause() { CurrentPlayStatus = Status.PAUSED; m_timeTween.Pause(); OnPause?.Invoke(FullProgress, CurrentPlayDirection); } /// \u0026lt;summary\u0026gt; /// 停止播放 /// \u0026lt;/summary\u0026gt; [Button] public void Stop() { CurrentPlayStatus = Status.STOPPED; m_timeTween.Kill(); FullProgress = 0d; m_playableDirector.time = FullProgress; m_playableDirector.Evaluate(); OnStop?.Invoke(FullProgress, CurrentPlayDirection); } [Button] public void JumpTo(double progress) { // 直接取样 m_playableDirector.time = progress; m_playableDirector.Evaluate(); FullProgress = progress; OnUpdate?.Invoke(progress); } [Button] public void ForceKill() { m_timeTween.Kill(); CurrentPlayStatus = Status.PAUSED; } private void ProgressExecute(double targetProgress) { // 使用DoTween最当前时间进行线性过渡 m_timeTween = DOTween.To(() =\u0026gt; FullProgress, x =\u0026gt; FullProgress = x, targetProgress, PlaySpeed).SetSpeedBased() .SetEase(Ease.Linear); // 做出限制避免bug FullProgress = Clamp(FullProgress, 0d, Duration); m_timeTween.OnUpdate(() =\u0026gt; { JumpTo(FullProgress); }); m_timeTween.OnComplete(() =\u0026gt; { CurrentPlayStatus = FullProgress == Duration ? Status.STOPPED : Status.PAUSED; OnAutoStop?.Invoke(FullProgress); }); m_timeTween.Play(); } /// \u0026lt;summary\u0026gt; /// 针对Double的Clamp /// \u0026lt;/summary\u0026gt; private static double Clamp(double value, double min, double max) { if (value \u0026lt; min) value = min; else if (value \u0026gt; max) value = max; return value; } } TimelineTestController 测试类创建一个场景自己制作一个Timeline, 绑定一些按钮。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 using System.Collections; using System.Collections.Generic; using Tools; using UnityEngine; using UnityEngine.Playables; using UnityEngine.UI; public class TimelineTestController : MonoBehaviour { public PlayableDirector PlayableDirector; public Button PlayForward; public Button PlayBackward; public Button Pause; public Button Stop; public Button Continue; public Button ContinueForward; public Button ContinueBackward; public TimelineDirector Director; public void Start() { Director = TimelineHelper.CreateTimelineDirector(PlayableDirector); Director.OnPlay = (t, d) =\u0026gt; { Debug.Log($\u0026#34;OnPlay time {t} dir {d}\u0026#34;); }; Director.OnPause = (t, d) =\u0026gt; { Debug.Log($\u0026#34;OnPause time {t} dir {d}\u0026#34;); }; Director.OnContinue = (t, d) =\u0026gt; { Debug.Log($\u0026#34;OnContinue time {t} dir {d}\u0026#34;); }; Director.OnStop = (t, d) =\u0026gt; { Debug.Log($\u0026#34;OnStop time {t} dir {d}\u0026#34;); }; PlayForward.onClick.AddListener(() =\u0026gt; { Director.PlayForward(); }); PlayBackward.onClick.AddListener(() =\u0026gt; { Director.PlayBackward(); }); Pause.onClick.AddListener(() =\u0026gt; { Director.Pause(); }); Stop.onClick.AddListener(() =\u0026gt; { Director.Stop(); }); Continue.onClick.AddListener(() =\u0026gt; { Director.Continue(); }); ContinueForward.onClick.AddListener(() =\u0026gt; { Director.ContinuePlayForwardByPausePoint(); }); ContinueBackward.onClick.AddListener(() =\u0026gt; { Director.ContinuePlayBackwardByPausePoint(); }); } } ","permalink":"https://0x4b404ec.github.io/posts/unityplayabledirector%E6%AD%A3%E6%92%AD%E5%80%92%E6%92%AD%E5%A4%84%E7%90%86/","summary":"Unity PlayableDirector(Timeline) 正播倒播处理 项目要求控制Timeline的播放状态，官方给出的方案只有正播的处理，并没有倒播的接口。\n而且网上搜索的一些方案都是使用协程，但是协程在处理中途暂停继续播放上比较难处理。\n所以自己随便写了一个。处理上比较傻瓜。\n下载DoTween插件 略\u0026hellip;\nTimelineHelper.cs 主要是提供了两个静态接口，用来实现挂TimelineDirector组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using UnityEngine; using UnityEngine.Playables; public static class PlayableExpansion { /// \u0026lt;summary\u0026gt; /// 为director添加自定义控制器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;director\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static PlayableController AddPlayableController(this PlayableDirector director) { return director.gameObject.AddComponent\u0026lt;PlayableController\u0026gt;(); } /// \u0026lt;summary\u0026gt; /// 为obj添加自定义控制器 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;obj\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static PlayableController AddPlayableController(this GameObject obj) { return obj.","title":"Unity PlayableDirector正播倒播处理"},{"content":"","permalink":"https://0x4b404ec.github.io/posts/test/","summary":"","title":""}]